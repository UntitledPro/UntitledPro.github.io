{"pages":[],"posts":[{"title":"BlogTemplates","text":"这里是简介.jpg Content window.changyan.api.config({ appid: 'cyvoWBcYh', conf: 'prod_82fb399b42af278fa503f42fe4c11ab1' });","link":"/2021/03/17/BlogTemplate/"},{"title":"blog","text":"什么也没有.jpg 一些代码过程中的总结 nn.Parameter(requires_grad=True)和torch.Tensor(requires_grad=True)的功能是相同的，都是创建了一个可学习的向量，但是不同之处在于，nn.Parameter所创建的是一个nn.Module的子类，就像是nn.layer一样，是包含在模型结构中的，但是torch.Tensor只是创建了一个向量 之所以经常用tensor.view()而非tensor.reshape，是因为view实在原有 tensor 上操作，不会占用多余的内存，而 reshape 是创建一个新的 tensor 在大量使用reshape 的情况下，可能会导致内存不足 window.changyan.api.config({ appid: 'cyvoWBcYh', conf: 'prod_82fb399b42af278fa503f42fe4c11ab1' });","link":"/2021/03/18/blog/"},{"title":"【数据集】：miniImageNet","text":"说明目前可用标签 Essay DataSets Pytorch Literature review 可用目录 Pytorch Dataset Python Paper notes DeepLearning Dataset Essay window.changyan.api.config({ appid: 'cyvoWBcYh', conf: 'prod_82fb399b42af278fa503f42fe4c11ab1' });","link":"/2021/04/14/miniImageNet/"},{"title":"【python】：生成器(generator)详解","text":"介绍python中的生成器 1 生成器(generator)在Python中，一边循环一边计算的机制，称为生成器：generator。 1.1 为什么使用生成器列表所有数据都在内存中，如果有海量数据的话将会非常耗内存。 如：仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 对于需要访问大数据集更是如此 如果列表元素按照某种算法推算出来，那我们就可以在循环的过程中不断推算出后续的元素，这样就不必创建完整的list，从而节省大量的空间。 简单一句话：又想要得到庞大的数据，又想让它占用空间少，那就用生成器. 1.2 创建生成器(introduce)1.2.1 简单示例123456789101112131415161718# 列表生成式lis = [x*x for x in range(10)]# &gt;&gt; [0, 1, 2, 3..., 9, 10]# 生成器# 生成器表达式：返回一个对象，这个对象只有在需要的时候才产生结果generator_ex = (x*x for x in range(10))# &gt;&gt; &lt;generator object &lt;genexpr&gt; at 0x000002A4CBF9EBA0&gt;# 生成器# 生成器函数：也是用def定义的，利用关键字yield一次性返回一个结果，阻塞，重新开始def fib(max): n,a,b =0,0,1 while n &lt; max: yield b a,b =b,a+b n = n+1 return 'done' 1.2.2 生成器函数生成器函数会随着时间的推移生成一个数值队列。一般的函数在执行完毕之后会返回一个值然后退出，但是生成器函数会自动挂起，然后重新拾起继续执行，他会利用yield关键字挂起函数，给调用者返回一个值，同时保留了当前的足够多的状态，可以使函数继续执行。 生成器和迭代协议是密切相关的，迭代器都有一个__next__()__成员方法，这个方法要么返回迭代的下一项，要么引起异常结束迭代。 12345678910111213141516171819202122# 函数有了yield之后，函数名+（）就变成了生成器# return在生成器中代表生成器的中止，直接报错# next的作用是唤醒并继续执行# send的作用是唤醒并继续执行，发送一个信息到生成器内部'''生成器'''def create_counter(n): print(&quot;create_counter&quot;) while True: yield n print(&quot;increment n&quot;) n +=1gen = create_counter(2)print(gen)# &lt;generator object create_counter at 0x0000023A1694A938&gt;print(next(gen))# create_counter# 2print(next(gen))# increment n# 3 1.2.3 生成器表达式生成器表达式来源于迭代和列表解析的组合，生成器和列表解析类似，但是它使用尖括号而不是方括号 1234567891011# 列表解析生成列表[ x ** 3 for x in range(5)]# &gt;&gt; [0, 1, 8, 27, 64]# 生成器表达式(x ** 3 for x in range(5))# &gt;&gt; &lt;generator object &lt;genexpr&gt; at 0x000000000315F678&gt;# 两者之间转换list(x ** 3 for x in range(5))# &gt;&gt; [0, 1, 8, 27, 64] 1.2.2 使用1.2.2.1 next()1234567def consumer(): r = 0 for i in xrange(3): # next 运行到这里结束 yield r # 第n(n&gt;1)次调用next时，从这里开始 r = '200 OK'+ str(i) 第一个next调用，相当于启动生成器，会从生成器函数的第一行代码开始执行，直到第一次执行完yield语句后，跳出生成器函数。 然后第二个next调用，进入生成器函数后，从yield语句的下一句语句开始执行，然后重新运行到yield语句。执行后，跳出生成器函数。 后面再次调用next，则依次类推。 next 的小问题generator保存的是算法，每次调用next(generaotr_ex)就计算出他的下一个元素的值，直到计算出最后一个元素，没有更多的元素时，抛出StopIteration的错误，而且不断调用是一个不好的习惯，正确的方法是使用for循环，因为generator也是可迭代对象。 123456789101112generator_ex = (x*x for x in range(10))print(next(generator_ex))# ...print(next(generator_ex))# Traceback (most recent call last):# File &quot;列表生成式.py&quot;, line 42, in &lt;module&gt;# print(next(generator_ex))# StopIteration 1.2.2.2 send(args)generator.next()，一定程度上等价于generator.send(None) 12345678910111213def consumer(): r = 'here' while True: n1 = yield r if not n1: return print('[CONSUMER] Consuming %s...' % n1) r = '%d00 OK' % n1c = consumer()c.send(None)c.send(1)c.send(2) 注意，n1 = yield r是从右向左执行。 第一次调用c.send(None)时，当yield r执行完毕后，是并没有将r赋值给n1的，此时，只是返回了r = 'here' 第二次调用c.send(1)时，将继续执行n1 = yield r，并将1赋值给n1，下面继续从yield的下一语句继续执行，然后重新运行到yield语句并跳出。 简单来看，send和next相比，只是开始多了一次赋值的动作，其他运行流程是相同的。 1.2.2.3 for123generator_ex = (x * x for x in range(10))for i in generator_ex: print(i) generator保存的是算法，每次调用next(generaotr_ex)就计算出他的下一个元素的值，直到计算出最后一个元素，没有更多的元素时，抛出StopIteration的错误，而且不断调用是一个不好的习惯，正确的方法是使用for循环，因为generator也是可迭代对象。 for 小问题所以当创建一个generator后，基本上永远不会调用next()，而是通过for循环来迭代，并且不需要关心StopIteration的错误，generator非常强大，如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。如在1.2.2 生成器函数中所创建的生成器函数 12345678910def fib(max): n,a,b =0,0,1 while n &lt; max: yield b a,b =b,a+b n = n+1 return 'done'for i in fib(6): print(i) 但是用for循环调用generator fib()时，发现拿不到generator的return语句的返回值。如果拿不到返回值，那么就会报错，所以需要进行异常处理，拿到返回值，如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中： 123456789101112131415161718def fib(max): n,a,b =0,0,1 while n &lt; max: yield b a,b =b,a+b n = n+1 return 'done'g = fib(6)while True: try: x = next(g) print('generator: ',x) except StopIteration as e: # 返回值 包含在StopIteration的value中 print(&quot;生成器返回值：&quot;,e.value) break window.changyan.api.config({ appid: 'cyvoWBcYh', conf: 'prod_82fb399b42af278fa503f42fe4c11ab1' });","link":"/2021/04/15/python-generator-iterator/"}],"tags":[{"name":"Templates","slug":"Templates","link":"/tags/Templates/"},{"name":"Essay","slug":"Essay","link":"/tags/Essay/"},{"name":"Pytorch","slug":"Pytorch","link":"/tags/Pytorch/"},{"name":"Dataset","slug":"Dataset","link":"/tags/Dataset/"},{"name":"miniImageNet","slug":"miniImageNet","link":"/tags/miniImageNet/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"generator","slug":"generator","link":"/tags/generator/"}],"categories":[{"name":"Templates","slug":"Templates","link":"/categories/Templates/"},{"name":"Pytorch","slug":"Pytorch","link":"/categories/Pytorch/"},{"name":"DeepLearning","slug":"DeepLearning","link":"/categories/DeepLearning/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"Blog","slug":"Templates/Blog","link":"/categories/Templates/Blog/"},{"name":"Dataset","slug":"DeepLearning/Dataset","link":"/categories/DeepLearning/Dataset/"},{"name":"Dataset","slug":"Pytorch/Dataset","link":"/categories/Pytorch/Dataset/"}]}