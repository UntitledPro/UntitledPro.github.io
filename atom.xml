<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wind&#39;s blog</title>
  
  
  <link href="https://untitledpro.github.io/atom.xml" rel="self"/>
  
  <link href="https://untitledpro.github.io/"/>
  <updated>2021-04-15T11:16:03.514Z</updated>
  <id>https://untitledpro.github.io/</id>
  
  <author>
    <name>Joe Done</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Issue】：博客无法正确显示图床图片（Failed to load resource net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH）</title>
    <link href="https://untitledpro.github.io/2021/04/15/PicIssue/"/>
    <id>https://untitledpro.github.io/2021/04/15/PicIssue/</id>
    <published>2021-04-15T10:50:37.599Z</published>
    <updated>2021-04-15T11:16:03.514Z</updated>
    
    <content type="html"><![CDATA[<!-- original template --><!-- ---title: 【Issue】：博客无法正确显示图床图片（Failed to load resource net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH）<p>date: 1618483837599<br>tags:<br>— –&gt;</p><!-- 简介(more/excerpt) --><p>使用了七牛云做图床，这样引用图片的时候可以直接输入url，CDN也加快了网站加载速度。但是当博客上传后，图片却无法正常显示，url链接是没问题的</p><span id="more"></span><!-- content --><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>使用了七牛云做图床，这样引用图片的时候可以直接输入url，CDN也加快了网站加载速度。但是当博客上传后，图片却无法正常显示，url链接是没问题的</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>emmm，只是可能原因，因为我没有买一级域名，所以..也不太知道</p><p><a href="https://blog.csdn.net/weixin_44763569/article/details/109097351">这篇CSDN博客遇到了同样的问题</a></p><p>文中提到，之所以无法显示，是因为该图片的域名没有通过证书认证，在谷歌浏览器里面不被信任，从而导致了图片无法被正常显示的问题</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li>置一个有效的本地开发server的证书，并将证书添加信任，参考<a href="https://zhuanlan.zhihu.com/p/26646377?group_id=850089475924185088">使用OpenSSL生成多域名自签名证书进行HTTPS开发调试 - 知乎专栏</a><br>有(you)机(qian)会(le)试一试（；´д｀）ゞ</li><li><a href="https://phoenixnap.com/kb/fix-err-ssl-version-or-cipher-mismatch">这篇博客比较详细的介绍了如何解决ERR_SSL_VERSION_OR_CIPHER_MISMATCH 问题</a></li></ul><!-- Gallary --><!-- <div class="justified-gallery">![pic1](https://img0.baidu.com/it/u=2151136234,3513236673&fm=26&fmt=auto&gp=0.jpg)![pic2](https://img2.baidu.com/it/u=3206689113,2237998950&fm=26&fmt=auto&gp=0.jpg)</div> --><!-- comment --><!--PC版/需要为每篇博客提供不同的 sid--><!-- sid Template: 20210414:name(: kwargs) --><div id="SOHUCS" sid="20210415PicIssue"></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cyvoWBcYh',conf: 'prod_82fb399b42af278fa503f42fe4c11ab1'});</script><!-- share button --><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=607409f7a784de0012cc7bda&product=inline-share-buttons" async="async"></script>]]></content>
    
    
    <summary type="html">&lt;!-- original template --&gt;
&lt;!-- ---
title: 【Issue】：博客无法正确显示图床图片（Failed to load resource net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH）
&lt;p&gt;date: 1618483837599&lt;br&gt;tags:&lt;br&gt;— –&amp;gt;&lt;/p&gt;
&lt;!-- 简介(more/excerpt) --&gt;

&lt;p&gt;使用了七牛云做图床，这样引用图片的时候可以直接输入url，CDN也加快了网站加载速度。但是当博客上传后，图片却无法正常显示，url链接是没问题的&lt;/p&gt;</summary>
    
    
    
    <category term="Issue" scheme="https://untitledpro.github.io/categories/Issue/"/>
    
    
    <category term="BlogIssue" scheme="https://untitledpro.github.io/tags/BlogIssue/"/>
    
  </entry>
  
  <entry>
    <title>【python】：迭代器相关概念汇总（容器，迭代器，生成器）</title>
    <link href="https://untitledpro.github.io/2021/04/15/python-iteratorFamily/"/>
    <id>https://untitledpro.github.io/2021/04/15/python-iteratorFamily/</id>
    <published>2021-04-15T08:08:00.750Z</published>
    <updated>2021-04-15T11:15:43.704Z</updated>
    
    <content type="html"><![CDATA[<!-- 简介(more/excerpt) --><p>介绍python中 iterable 的相关概念，包括 container，iterable，iterator，generator</p><span id="more"></span><!-- content --><p>Container, Iterator, generator 之间的关系如下:</p><p><img src="http://qrj7ixmty.hn-bkt.clouddn.com/python/relationships_of_iterables.jpg" alt="relationships between Container, Iterator and Generator"></p><h2 id="1-Container"><a href="#1-Container" class="headerlink" title="1. Container"></a>1. Container</h2><p>Container 是存储数据的数据结构，同时也支持成员检索。Container 的所有数据都是储存在内存中的。一些常见的 Container有：</p><ul><li>list</li><li>set</li><li>dict</li><li>tuple</li><li>str</li><li>…</li></ul><p>Container 很容易理解，你可以把它想象为现实生活中的容器，比如盒子，房屋，橱柜等等。</p><p>当可以询问对象是否包含某个元素时，它就是一个容器。可以对 list、set 或 tuple 执行此类成员资格测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list</span></span><br><span class="line"><span class="comment"># 1 不在 [1,2,3]中时报错...</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">1</span> <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">assert</span> <span class="number">4</span> <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># set</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">1</span> <span class="keyword">in</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">assert</span> <span class="number">4</span> <span class="keyword">not</span> <span class="keyword">in</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>对于字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="number">1</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">assert</span> <span class="number">1</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="comment"># 由于 a 并不是 dict d 的 key，所以下面语句会报错</span></span><br><span class="line"><span class="keyword">assert</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> d</span><br></pre></td></tr></table></figure><blockquote><p>NOTE:<br>Even though most containers provide a way to produce every element they contain, that ability does not make them a <strong>container</strong> but an <strong>iterable</strong>.<br><strong>Not all containers</strong> are necessarily <strong>iterable</strong>. An example of this is a Bloom filter. Probabilistic data structures like this can be asked whether they contain a certain element, but they are unable to return their individual elements.</p></blockquote><h2 id="2-Iterables"><a href="#2-Iterables" class="headerlink" title="2. Iterables"></a>2. Iterables</h2><p>如前所述，大部分的 Container 都是可迭代对象，同样很多非 Container 的对象也是可迭代的。在 Container 只能表示有限数据的情况下，一个可迭代对象可能能代表一个无限的数据源。</p><p>可迭代对象可以是任何一个可以返回 iterator(迭代器) 的对象，并非一定是一种数据结构。</p><p>在 iterator(迭代器)和 iterable(可迭代对象)之间有很明显的区别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = <span class="built_in">iter</span>(x)</span><br><span class="line"><span class="built_in">next</span>(y)</span><br><span class="line"><span class="comment"># &gt;&gt; 1</span></span><br><span class="line"><span class="built_in">next</span>(y)</span><br><span class="line"><span class="comment"># &gt;&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span>(x)</span><br><span class="line"><span class="comment"># &gt;&gt; &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"><span class="built_in">type</span>(y)</span><br><span class="line"><span class="comment"># &gt;&gt; &lt;class &#x27;list_iterator&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>如上代码块所示，x 是一个list， 即一个可迭代对象（iterable），而 y 是一个迭代器（iterator）</p><h3 id="2-1-实现方法"><a href="#2-1-实现方法" class="headerlink" title="2.1 实现方法"></a>2.1 实现方法</h3><ol><li>内置函数<code>iter()</code>实际是映射到了<code>__iter__</code>函数</li><li>只要实现了<code>__iter__</code>的对象就是**可迭代对象(Iterable)**，正常情况下，应该返回一个实现了<code>__next__</code>的对象(虽然这个要求不强制)，如果自己实现了<code>__next__</code>，当然也可以返回自己</li><li>同时实现了<code>__iter__</code>和<code>__next__</code>的是**迭代器(Iterator)**，当然也是一个可迭代对象了，其中<code>__next__</code>应该在迭代完成后，抛出一个<code>StopIteration</code>异常</li><li>for语句会自动处理这个<code>StopIteration</code>异常以便结束for循环</li></ol><p>当写出如下代码时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> i  <span class="keyword">in</span> x:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>实际上执行了如下动作：</p><p><img src="http://qrj7ixmty.hn-bkt.clouddn.com/python/iterable%20for%20loop.png" alt="iterable for loop"></p><h2 id="3-iterator"><a href="#3-iterator" class="headerlink" title="3. iterator"></a>3. iterator</h2><p>其实刚刚提到过， 一个迭代器（iterator）就是同时实现了<code>__iter__</code>和<code>__next__</code>方法的对象，当在该对象上调用内置函数<code>next()</code>时，会产出下一个值。</p><p>一个实现了iter方法的对象是可迭代的，一个实现next方法并且是可迭代的对象是迭代器。可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。</p><p>迭代器的实例有很多，有的产生有限序列，有的产生无限序列，下面举一个能产生无限序列的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> cycle</span><br><span class="line">colors = cycle([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>])</span><br><span class="line"><span class="built_in">next</span>(colors)</span><br><span class="line"><span class="comment"># &gt;&gt; red -&gt; white -&gt; blue -&gt; red -&gt; white -&gt; ...</span></span><br></pre></td></tr></table></figure><p>为了更好地了解迭代器的搭建原理，让我们构建一个生成斐波那契数的迭代器（经典.jpg）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fib</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.prev = <span class="number">0</span></span><br><span class="line">    self. curr = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">    value = self.curr</span><br><span class="line">    self.curr = sefl.curr + sefl.prev</span><br><span class="line">    self.prev = value</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">f = fib()</span><br><span class="line"><span class="built_in">list</span>(islice(f, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line"><span class="comment"># &gt;&gt; [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span></span><br><span class="line"><span class="comment"># Note that this class is both an iterable (because it sports an __iter__() method), and its own iterator (because it has a __next__() method).</span></span><br></pre></td></tr></table></figure><p>请注意，此类既是可迭代的（因为它使用<code>__iter__()</code>方法），又是自己的迭代器（因为它具有<code>__next__()</code>方法）。</p><blockquote><p>Central idea: a lazy factory<br>From the outside, the iterator is like a lazy factory that is idle until you ask it for a value, which is when it starts to buzz and produce a single value, after which it turns idle again.</p></blockquote><h2 id="4-Generator"><a href="#4-Generator" class="headerlink" title="4. Generator"></a>4. Generator</h2><p>生成器(generator)是一种特殊的迭代器(iterator)，在 Python 中，使用了 <code>yield</code> 的函数被称为生成器(generator)</p><p>生成器是一个<strong>返回迭代器</strong>的函数，只能用于迭代操作，更简单点理解<strong>生成器就是一个迭代器</strong>。</p><p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 <code>next()</code> 方法时从当前位置继续运行。</p><p><em>调用一个生成器函数，返回的是一个迭代器对象。</em></p><h3 id="生成器的种类"><a href="#生成器的种类" class="headerlink" title="生成器的种类"></a>生成器的种类</h3><h4 id="4-1-生成器函数"><a href="#4-1-生成器函数" class="headerlink" title="4.1 生成器函数"></a>4.1 生成器函数</h4><p>生成器函数会随着时间的推移生成一个数值队列。一般的函数在执行完毕之后会返回一个值然后退出，但是生成器函数会自动挂起，然后重新拾起继续执行，他会利用yield关键字挂起函数，给调用者返回一个值，同时保留了当前的足够多的状态，可以使函数继续执行。</p><p>生成器和迭代协议是密切相关的，<strong>迭代器</strong>都有一个__next__()__成员方法，这个方法要么返回迭代的下一项，要么引起异常结束迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数有了yield之后，函数名+（）就变成了生成器</span></span><br><span class="line"><span class="comment"># return在生成器中代表生成器的中止，直接报错</span></span><br><span class="line"><span class="comment"># next的作用是唤醒并继续执行</span></span><br><span class="line"><span class="comment"># send的作用是唤醒并继续执行，发送一个信息到生成器内部</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;生成器&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_counter</span>(<span class="params">n</span>):</span></span><br><span class="line">  print(<span class="string">&quot;create_counter&quot;</span>)</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">yield</span> n</span><br><span class="line">    print(<span class="string">&quot;increment n&quot;</span>)</span><br><span class="line">    n +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">gen = create_counter(<span class="number">2</span>)</span><br><span class="line">print(gen)</span><br><span class="line"><span class="comment"># &lt;generator object create_counter at 0x0000023A1694A938&gt;</span></span><br><span class="line">print(<span class="built_in">next</span>(gen))</span><br><span class="line"><span class="comment"># create_counter</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">print(<span class="built_in">next</span>(gen))</span><br><span class="line"><span class="comment"># increment n</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure><h4 id="4-2-生成器表达式"><a href="#4-2-生成器表达式" class="headerlink" title="4.2 生成器表达式"></a>4.2 生成器表达式</h4><p><strong>生成器表达式</strong>来源于<strong>迭代</strong>和<strong>列表解析</strong>的组合，生成器和列表解析类似，但是它使用<strong>尖括号</strong>而不是<strong>方括号</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表解析生成列表</span></span><br><span class="line">[ x ** <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="comment"># &gt;&gt; [0, 1, 8, 27, 64]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器表达式</span></span><br><span class="line">(x ** <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="comment"># &gt;&gt; &lt;generator object &lt;genexpr&gt; at 0x000000000315F678&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两者之间转换</span></span><br><span class="line"><span class="built_in">list</span>(x ** <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="comment"># &gt;&gt; [0, 1, 8, 27, 64]</span></span><br></pre></td></tr></table></figure><h2 id="5-Summary"><a href="#5-Summary" class="headerlink" title="5. Summary"></a>5. Summary</h2><ul><li>只要实现了<code>__iter__</code>的对象就是 **可迭代对象(Iterable)**，正常情况下，应该返回一个实现了<code>__next__</code>的对象(虽然这个要求不强制)，如果自己实现了<code>__next__</code>，当然也可以返回自己</li><li>凡是可作用于for循环的对象都是 <strong>可迭代对象(Iterable)</strong> ；</li><li>同时实现了<code>__iter__</code>和<code>__next__</code>的是**迭代器(Iterator)**，当然也是一个可迭代对象了，其中<code>__next__</code>应该在迭代完成后，抛出一个<code>StopIteration</code>异常</li><li>凡是可作用于next()函数的对象都是 <strong>迭代器(Iterator)</strong> 类型，它们表示一个惰性计算的序列；</li><li>集合数据类型如list、dict、str等是 <strong>可迭代对象(Iterable)</strong> 但不是 <strong>迭代器(Iterator)</strong> ，不过可以通过<code>iter()</code>函数获得一个  <strong>迭代器(Iterator)</strong> 对象。</li><li>内置函数<code>iter()</code>实际是映射到了<code>__iter__</code>函数</li><li>for语句会自动处理这个<code>StopIteration</code>异常以便结束for循环<!-- Gallary --><!-- <div class="justified-gallery"></li></ul><p><img src="https://img0.baidu.com/it/u=2151136234,3513236673&fm=26&fmt=auto&gp=0.jpg" alt="pic1"><br><img src="https://img2.baidu.com/it/u=3206689113,2237998950&fm=26&fmt=auto&gp=0.jpg" alt="pic2"></p></div> --><!-- comment --><!--PC版/需要为每篇博客提供不同的 sid--><!-- sid Template: 20210414:name(: kwargs) --><div id="SOHUCS" sid="20210415iteratorFamily"></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cyvoWBcYh',conf: 'prod_82fb399b42af278fa503f42fe4c11ab1'});</script><!-- share button --><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=607409f7a784de0012cc7bda&product=inline-share-buttons" async="async"></script>]]></content>
    
    
    <summary type="html">&lt;!-- 简介(more/excerpt) --&gt;

&lt;p&gt;介绍python中 iterable 的相关概念，包括 container，iterable，iterator，generator&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://untitledpro.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://untitledpro.github.io/tags/Python/"/>
    
    <category term="Generator" scheme="https://untitledpro.github.io/tags/Generator/"/>
    
    <category term="Container" scheme="https://untitledpro.github.io/tags/Container/"/>
    
    <category term="Iterable" scheme="https://untitledpro.github.io/tags/Iterable/"/>
    
    <category term="Iterator" scheme="https://untitledpro.github.io/tags/Iterator/"/>
    
  </entry>
  
  <entry>
    <title>【python】：生成器(generator)详解</title>
    <link href="https://untitledpro.github.io/2021/04/15/python-generator/"/>
    <id>https://untitledpro.github.io/2021/04/15/python-generator/</id>
    <published>2021-04-15T02:45:25.943Z</published>
    <updated>2021-04-15T08:35:28.120Z</updated>
    
    <content type="html"><![CDATA[<p>介绍python中的生成器</p><!-- 简介(more/excerpt) --><span id="more"></span><p><img src="http://qrj7ixmty.hn-bkt.clouddn.com/python/relationships_of_iterables.jpg" alt="generator&lt;-&gt;container&lt;-&gt;iterator"></p><h2 id="1-生成器-generator"><a href="#1-生成器-generator" class="headerlink" title="1 生成器(generator)"></a>1 生成器(generator)</h2><p>在Python中，一边循环一边计算的机制，称为生成器：generator。</p><h3 id="1-1-为什么使用生成器"><a href="#1-1-为什么使用生成器" class="headerlink" title="1.1 为什么使用生成器"></a>1.1 为什么使用生成器</h3><p>列表所有数据都在内存中，如果有海量数据的话将会非常耗内存。</p><p>如：仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p><p>对于需要访问大数据集更是如此</p><p>如果列表元素按照某种算法推算出来，那我们就可以在循环的过程中不断推算出后续的元素，这样就不必创建完整的list，从而节省大量的空间。</p><p>简单一句话：又想要得到庞大的数据，又想让它占用空间少，那就用生成器.</p><h3 id="1-2-创建生成器-introduce"><a href="#1-2-创建生成器-introduce" class="headerlink" title="1.2 创建生成器(introduce)"></a>1.2 创建生成器(introduce)</h3><h4 id="1-2-1-简单示例"><a href="#1-2-1-简单示例" class="headerlink" title="1.2.1 简单示例"></a>1.2.1 简单示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表生成式</span></span><br><span class="line">lis = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="comment"># &gt;&gt; [0, 1, 2, 3..., 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器</span></span><br><span class="line"><span class="comment"># 生成器表达式：返回一个对象，这个对象只有在需要的时候才产生结果</span></span><br><span class="line">generator_ex = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="comment"># &gt;&gt; &lt;generator object &lt;genexpr&gt; at 0x000002A4CBF9EBA0&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器</span></span><br><span class="line"><span class="comment"># 生成器函数：也是用def定义的，利用关键字yield一次性返回一个结果，阻塞，重新开始</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span></span><br><span class="line">    n,a,b =<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a,b =b,a+b</span><br><span class="line">        n = n+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="1-2-2-生成器函数"><a href="#1-2-2-生成器函数" class="headerlink" title="1.2.2 生成器函数"></a><div id='122'>1.2.2 生成器函数</div></h4><p>生成器函数会随着时间的推移生成一个数值队列。一般的函数在执行完毕之后会返回一个值然后退出，但是生成器函数会自动挂起，然后重新拾起继续执行，他会利用yield关键字挂起函数，给调用者返回一个值，同时保留了当前的足够多的状态，可以使函数继续执行。</p><p>生成器和迭代协议是密切相关的，<strong>迭代器</strong>都有一个__next__()__成员方法，这个方法要么返回迭代的下一项，要么引起异常结束迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数有了yield之后，函数名+（）就变成了生成器</span></span><br><span class="line"><span class="comment"># return在生成器中代表生成器的中止，直接报错</span></span><br><span class="line"><span class="comment"># next的作用是唤醒并继续执行</span></span><br><span class="line"><span class="comment"># send的作用是唤醒并继续执行，发送一个信息到生成器内部</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;生成器&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_counter</span>(<span class="params">n</span>):</span></span><br><span class="line">  print(<span class="string">&quot;create_counter&quot;</span>)</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">yield</span> n</span><br><span class="line">    print(<span class="string">&quot;increment n&quot;</span>)</span><br><span class="line">    n +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">gen = create_counter(<span class="number">2</span>)</span><br><span class="line">print(gen)</span><br><span class="line"><span class="comment"># &lt;generator object create_counter at 0x0000023A1694A938&gt;</span></span><br><span class="line">print(<span class="built_in">next</span>(gen))</span><br><span class="line"><span class="comment"># create_counter</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">print(<span class="built_in">next</span>(gen))</span><br><span class="line"><span class="comment"># increment n</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure><h4 id="1-2-3-生成器表达式"><a href="#1-2-3-生成器表达式" class="headerlink" title="1.2.3 生成器表达式"></a>1.2.3 生成器表达式</h4><p><strong>生成器表达式</strong>来源于<strong>迭代</strong>和<strong>列表解析</strong>的组合，生成器和列表解析类似，但是它使用<strong>尖括号</strong>而不是<strong>方括号</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表解析生成列表</span></span><br><span class="line">[ x ** <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="comment"># &gt;&gt; [0, 1, 8, 27, 64]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器表达式</span></span><br><span class="line">(x ** <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="comment"># &gt;&gt; &lt;generator object &lt;genexpr&gt; at 0x000000000315F678&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两者之间转换</span></span><br><span class="line"><span class="built_in">list</span>(x ** <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="comment"># &gt;&gt; [0, 1, 8, 27, 64]</span></span><br></pre></td></tr></table></figure><h3 id="1-2-2-使用"><a href="#1-2-2-使用" class="headerlink" title="1.2.2 使用"></a>1.2.2 使用</h3><h4 id="1-2-2-1-next"><a href="#1-2-2-1-next" class="headerlink" title="1.2.2.1 next()"></a>1.2.2.1 next()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>():</span></span><br><span class="line">  r = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">3</span>):</span><br><span class="line">    <span class="comment"># next 运行到这里结束</span></span><br><span class="line">    <span class="keyword">yield</span> r</span><br><span class="line">    <span class="comment"># 第n(n&gt;1)次调用next时，从这里开始</span></span><br><span class="line">    r = <span class="string">&#x27;200 OK&#x27;</span>+ <span class="built_in">str</span>(i)</span><br></pre></td></tr></table></figure><p>第一个<strong>next</strong>调用，相当于启动生成器，会从生成器函数的第一行代码开始执行，直到第一次执行完<strong>yield</strong>语句后，跳出生成器函数。</p><p>然后第二个<strong>next</strong>调用，进入生成器函数后，从<strong>yield</strong>语句的下一句语句开始执行，然后重新运行到<strong>yield</strong>语句。执行后，跳出生成器函数。</p><p>后面再次调用<strong>next</strong>，则依次类推。</p><hr><h5 id="next-的小问题"><a href="#next-的小问题" class="headerlink" title="next 的小问题"></a>next 的小问题</h5><p>generator保存的是算法，每次调用<code>next(generaotr_ex)</code>就计算出他的下一个元素的值，直到计算出最后一个元素，没有更多的元素时，抛出<code>StopIteration</code>的错误，而且不断调用是一个不好的习惯，正确的方法是使用for循环，因为generator也是可迭代对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">generator_ex = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">print(<span class="built_in">next</span>(generator_ex))</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">print(<span class="built_in">next</span>(generator_ex))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   File &quot;列表生成式.py&quot;, line 42, in &lt;module&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     print(next(generator_ex))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure><h4 id="1-2-2-2-send-args"><a href="#1-2-2-2-send-args" class="headerlink" title="1.2.2.2 send(args)"></a>1.2.2.2 send(args)</h4><p>generator.next()，一定程度上等价于generator.send(None)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>():</span></span><br><span class="line">  r = <span class="string">&#x27;here&#x27;</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    n1 = <span class="keyword">yield</span> r</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> n1:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    print(<span class="string">&#x27;[CONSUMER] Consuming %s...&#x27;</span> % n1)</span><br><span class="line">    r = <span class="string">&#x27;%d00 OK&#x27;</span> % n1</span><br><span class="line"></span><br><span class="line">c = consumer()</span><br><span class="line">c.send(<span class="literal">None</span>)</span><br><span class="line">c.send(<span class="number">1</span>)</span><br><span class="line">c.send(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>注意，<code>n1 = yield r</code>是<strong>从右向左</strong>执行。</p><p>第一次调用<code>c.send(None)</code>时，当<code>yield r</code>执行完毕后，是并没有将<strong>r</strong>赋值给<strong>n1</strong>的，此时，只是返回了<code>r = &#39;here&#39;</code></p><p>第二次调用<code>c.send(1)</code>时，将继续执行<code>n1 = yield r</code>，并将<strong>1</strong>赋值给<strong>n1</strong>，下面继续从yield的下一语句继续执行，然后重新运行到yield语句并跳出。</p><p><strong>简单来看，send和next相比，只是开始多了一次赋值的动作，其他运行流程是相同的。</strong></p><h4 id="1-2-2-3-for"><a href="#1-2-2-3-for" class="headerlink" title="1.2.2.3 for"></a>1.2.2.3 for</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">generator_ex = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> generator_ex:</span><br><span class="line">  print(i)</span><br></pre></td></tr></table></figure><p>generator保存的是算法，每次调用<code>next(generaotr_ex)</code>就计算出他的下一个元素的值，直到计算出最后一个元素，没有更多的元素时，抛出<code>StopIteration</code>的错误，而且不断调用是一个不好的习惯，正确的方法是使用for循环，因为generator也是可迭代对象。</p><hr><h5 id="for-小问题"><a href="#for-小问题" class="headerlink" title="for 小问题"></a>for 小问题</h5><p>所以当创建一个generator后，基本上永远不会调用<code>next()</code>，而是通过for循环来迭代，并且不需要关心<code>StopIteration</code>的错误，generator非常强大，如果推算的算法比较复杂，用类似<strong>列表生成式</strong>的for循环无法实现的时候，还可以用函数来实现。如在<a href="#122">1.2.2 生成器函数</a>中所创建的<strong>生成器函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span></span><br><span class="line">    n,a,b =<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a,b =b,a+b</span><br><span class="line">        n = n+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fib(<span class="number">6</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>但是用for循环调用<strong>generator fib()<strong>时，发现拿不到</strong>generator</strong>的<strong>return</strong>语句的返回值。如果拿不到返回值，那么就会报错，所以需要进行异常处理，拿到返回值，如果想要拿到返回值，必须<strong>捕获StopIteration错误</strong>，<strong>返回值</strong>包含在<strong>StopIteration的value中</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span></span><br><span class="line">  n,a,b =<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">    <span class="keyword">yield</span> b</span><br><span class="line">    a,b =b,a+b</span><br><span class="line">    n = n+<span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br><span class="line"></span><br><span class="line">g = fib(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    x = <span class="built_in">next</span>(g)</span><br><span class="line">    print(<span class="string">&#x27;generator: &#x27;</span>,x)</span><br><span class="line">  <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 返回值 包含在StopIteration的value中</span></span><br><span class="line">    print(<span class="string">&quot;生成器返回值：&quot;</span>,e.value)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><!-- Gallary --><!-- <div class="justified-gallery">![pic1](https://img0.baidu.com/it/u=2151136234,3513236673&fm=26&fmt=auto&gp=0.jpg)![pic2](https://img2.baidu.com/it/u=3206689113,2237998950&fm=26&fmt=auto&gp=0.jpg)</div> --><!-- comment --><!--PC版/需要为每篇博客提供不同的 sid--><!-- sid Template: 20210414:name(: kwargs) --><div id="SOHUCS" sid="20210415PythonGenerator"></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cyvoWBcYh',conf: 'prod_82fb399b42af278fa503f42fe4c11ab1'});</script><!-- share button --><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=607409f7a784de0012cc7bda&product=inline-share-buttons" async="async"></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍python中的生成器&lt;/p&gt;
&lt;!-- 简介(more/excerpt) --&gt;</summary>
    
    
    
    <category term="Python" scheme="https://untitledpro.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://untitledpro.github.io/tags/Python/"/>
    
    <category term="Generator" scheme="https://untitledpro.github.io/tags/Generator/"/>
    
  </entry>
  
  <entry>
    <title>【数据集】：miniImageNet</title>
    <link href="https://untitledpro.github.io/2021/04/14/miniImageNet/"/>
    <id>https://untitledpro.github.io/2021/04/14/miniImageNet/</id>
    <published>2021-04-14T08:22:53.135Z</published>
    <updated>2021-04-15T11:16:08.014Z</updated>
    
    <content type="html"><![CDATA[<!-- 简介(more/excerpt) --><span id="more"></span><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="目前可用标签"><a href="#目前可用标签" class="headerlink" title="目前可用标签"></a>目前可用标签</h3><ul><li>Essay</li><li>DataSets</li><li>Pytorch</li><li>Literature review</li></ul><h3 id="可用目录"><a href="#可用目录" class="headerlink" title="可用目录"></a>可用目录</h3><ul><li>Pytorch<ul><li>Dataset</li></ul></li><li>Python</li><li>Paper notes</li><li>DeepLearning<ul><li>Dataset</li></ul></li><li>Essay</li></ul><!-- Gallary --><!-- <div class="justified-gallery">![pic1](https://img0.baidu.com/it/u=2151136234,3513236673&fm=26&fmt=auto&gp=0.jpg)![pic2](https://img2.baidu.com/it/u=3206689113,2237998950&fm=26&fmt=auto&gp=0.jpg)</div> --><!-- comment --><!--PC版/需要为每篇博客提供不同的 sid--><!-- sid Template: 20210414:name(: kwargs) --><div id="SOHUCS" sid="20210415miniImageNet"></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cyvoWBcYh',conf: 'prod_82fb399b42af278fa503f42fe4c11ab1'});</script><!-- share button --><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=607409f7a784de0012cc7bda&product=inline-share-buttons" async="async"></script>]]></content>
    
    
    <summary type="html">&lt;!-- 简介(more/excerpt) --&gt;</summary>
    
    
    
    <category term="DeepLearning" scheme="https://untitledpro.github.io/categories/DeepLearning/"/>
    
    <category term="Pytorch" scheme="https://untitledpro.github.io/categories/Pytorch/"/>
    
    <category term="Dataset" scheme="https://untitledpro.github.io/categories/DeepLearning/Dataset/"/>
    
    <category term="Dataset" scheme="https://untitledpro.github.io/categories/Pytorch/Dataset/"/>
    
    
    <category term="Dataset" scheme="https://untitledpro.github.io/tags/Dataset/"/>
    
    <category term="miniImageNet" scheme="https://untitledpro.github.io/tags/miniImageNet/"/>
    
    <category term="Pytorch" scheme="https://untitledpro.github.io/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>随便记记-测试用的</title>
    <link href="https://untitledpro.github.io/2021/03/18/blog/"/>
    <id>https://untitledpro.github.io/2021/03/18/blog/</id>
    <published>2021-03-18T09:41:49.607Z</published>
    <updated>2021-04-15T11:15:23.074Z</updated>
    
    <content type="html"><![CDATA[<p>什么也没有.jpg</p><span id="more"></span><h2 id="一些代码过程中的总结"><a href="#一些代码过程中的总结" class="headerlink" title="一些代码过程中的总结"></a>一些代码过程中的总结</h2><ol><li><p><code>nn.Parameter(requires_grad=True)</code>和<code>torch.Tensor(requires_grad=True)</code>的功能是相同的，都是创建了一个可学习的向量，但是不同之处在于，<code>nn.Parameter</code>所创建的是一个<code>nn.Module</code>的子类，就像是<code>nn.layer</code>一样，是包含在模型结构中的，但是<code>torch.Tensor</code>只是创建了一个向量</p></li><li><p>之所以经常用<code>tensor.view()</code>而非<code>tensor.reshape</code>，是因为view实在原有 tensor 上操作，不会占用多余的内存，而 reshape 是创建一个新的 tensor 在大量使用reshape 的情况下，可能会导致内存不足</p></li></ol><!-- Gallary --><!-- <div class="justified-gallery">![Elephant](/hexo-theme-icarus/gallery/animals/elephant.jpeg)![Dog](/hexo-theme-icarus/gallery/animals/dog.jpeg)![Birds](/hexo-theme-icarus/gallery/animals/birds.jpeg)![Fox](/hexo-theme-icarus/gallery/animals/fox.jpeg)![Horse](/hexo-theme-icarus/gallery/animals/horse.jpeg)![Leopard](/hexo-theme-icarus/gallery/animals/leopard.jpeg)</div> --><!-- comment --><!--PC版--><div id="SOHUCS" sid="随便"></div><script charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js" ></script><script type="text/javascript">window.changyan.api.config({appid: 'cyvoWBcYh',conf: 'prod_82fb399b42af278fa503f42fe4c11ab1'});</script><!-- share button --><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=607409f7a784de0012cc7bda&product=inline-share-buttons" async="async"></script>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么也没有.jpg&lt;/p&gt;</summary>
    
    
    
    <category term="Pytorch" scheme="https://untitledpro.github.io/categories/Pytorch/"/>
    
    
    <category term="Pytorch" scheme="https://untitledpro.github.io/tags/Pytorch/"/>
    
    <category term="Essay" scheme="https://untitledpro.github.io/tags/Essay/"/>
    
  </entry>
  
</feed>
